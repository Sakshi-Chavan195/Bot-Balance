import numpy as np
def lqr(A,B,Q,R):
    p=np.matrix(np.zeros_like(A))
    p_next=np.matrix(np.zeros_like(A))
    maxI=100
    for _ in range(maxI):
        p_next=A.T*p*A-A.T*p*B*np.linalg.inv(R+B.T*p*B)*B.T*p*A+Q
        if np.allclose(p,p_next):
            break
        p=p_next   
    k=np.linalg.inv(R+B.T*p*B)*(B.T*p*A)
    return k 
def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts
    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    self.body=sim.getObject('/body')
    #sim.setObjectPosition(self.body,-1,[0,0,0.1])
    self.Ljoint=sim.getObject('/left_joint')
    self.Rjoint=sim.getObject('/right_joint')
    self.max_torque=2.5
    sim.setJointPosition(self.Ljoint,0.0)
    sim.setJointPosition(self.Rjoint,0.0)
    self.Q=np.diag([100,1,1000,1])
    self.R=np.diag([0.01])
    self.A=np.matrix([
        [0,1,0,0],
        [0,0,-5.698,0],
        [0,0,0,1],
        [0,0,9.81,0]
    ])
    self.B=np.matrix([
        [0],
        [11.63],
        [0],
        [-116.28]
    ])
    self.k=lqr(self.A,self.B,self.Q,self.R)
    self.state=np.zeros((4,1))
    self.dt=sim.getSimulationTimeStep()
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    
    ##################################
    
def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    cangleL=sim.getJointPosition(self.Ljoint)
    body_O=sim.getObjectOrientation(self.body,-1)
    cangleR=sim.getJointPosition(self.Rjoint)
    cpos=(cangleL+cangleR)/2
    cvel=(sim.getJointVelocity(self.Ljoint)+sim.getJointVelocity(self.Rjoint))/2
    self.state[0]=cpos
    self.state[1]=cvel
    self.state[2]=body_O[1]
    self.state[3]=(sim.getJointVelocity(self.Ljoint)-sim.getJointVelocity(self.Rjoint))/2
    u=-self.k*self.state
    u_sat=u[0,0]
    sim.setJointTargetVelocity(self.Ljoint,u_sat)
    sim.setJointTargetVelocity(self.Rjoint,u_sat)
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    pass

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
    pass

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass
